# Ginger

Gingerは、AIと人間が同じテーブルにつき、
静かにシステムを組み立てていくことを前提としたプログラミング言語だ。

この言語では、設計と実装は最初から分けて書かれる。
そうすることで、関数は「何をするのか」だけでなく、
「なぜそこにあるのか」を自然に語り始める。

またGingerでは、各関数が失敗する可能性をあらかじめ言葉にして残す。
成功だけが結果ではない。
失敗もまた、そこで何が起こり得るのかを示す、一つの成果として扱われる。

Gingerは、正しく動くことよりも、
壊れたときに立ち止まれることを重視する。

すでに通った思考や判断を、
もう一度なぞる必要はない。
失敗は原因としてではなく、
次に進むための位置情報として残される。

それは、
誰も全体を把握しなくても、
同じ失敗を繰り返さずに進むための、
合理的な態度である。

---

## コンセプト

Gingerは、「正しく動くプログラム」を作ることよりも、
どのような判断のもとで設計され、実装されたかが残ることを重視する。

多くのプログラミング言語では、
設計はドキュメントとしてコードの外に置かれ、
実装はコードの内部に閉じられる。
その結果、時間の経過とともに、
設計と実装のあいだには少しずつズレが生じていく。

そのズレは、誰かの不注意によって生まれるのではない。
時間が流れ、人が考え続ける以上、
避けることのできないものだ。

だからこそGingerでは、
設計と実装を最初から分離した層として記述する。
ズレをなくすためではなく、
ズレがどこで生じたのかを、
静かに置けるようにするためだ。

またGingerでは、
各関数が持つ失敗の可能性（failure）を
明示的に記録することを義務付けている。
ここでいう failure は、例外や想定外の事故ではない。
作り手があらかじめ想定し、
起こり得るものとして言葉にした結果である。

作り手が何を成功とし、
どのような失敗を想定しているのか。

その両方が書かれてはじめて、
関数は単なる処理の集合ではなく、
一つの判断として、そこに立ち上がる。

Gingerは、
AIと人間が同じ設計を共有し、
同じ前提のもとで実装を進めていくための言語である。
そこでは成功と失敗は対立するものではなく、
どちらも等しく、
思考と判断の痕跡として残される。

---

## Catalog.ginger

`Catalog.ginger` は、Ginger の世界で **何が存在できるか** を定義します。

例：
```
catalog Sample

type Int

fn add
args: Int, Int
return: Int
description: “Adds two integers.”
```

### 特徴

- 関数定義は **catalog のみ**
- `args` / `return` は必須
- `description` は任意（ドキュメント用途）
- インデントは意味を持たない（行ベース）

---

## Code.ginger

`code.ginger` には、**実行したい式だけ**を書きます。

例：
add(1, 2)

## python run_ginger.py

- `Catalog.ginger` を読み込む
- `Code.ginger` をパースする
- Catalog に基づいて関数の引数および戻り値の型をチェックする
- 最小実装された関数を評価する

---

## 型チェックについて（v0）

現在の Ginger は：

- **catalog に書かれた型名を基準にチェック**
- 型名は Python の型にマッピングして検証

例：

```python
TYPEMAP = {
    "Int": int,
}
```
